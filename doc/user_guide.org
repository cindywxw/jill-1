#-*- mode: org -*-
#+STARTUP:    align fold hidestars oddeven
#+TITLE:    JILL Real-Time Audio Framework - User Guide
#+AUTHOR:    Dan Meliza
#+EMAIL:     dan@meliza.org
#+LANGUAGE:   en
#+OPTIONS: ^:nil H:2
#+STYLE:    <link rel="stylesheet" href="org.css" type="text/css" />

*JILL* consists of a set of modules (programs) that use the JACK realtime audio
framework to run auditory behavioral and neuroscience experiments.  This
document describes how to get started using JILL with some common use cases.

* Basic operation

The first thing to do is start up the JACK server and connect it to the sound
card. We'll use =qjackctl= to demonstrate (see [[qjackctl]] for instructions on
installing this program), but it's also possible to do all of these actions from
the command line.

The =qjackctl= interface initially looks like this:

[[file:qjackctl.png]]

To configure the JACK server, click setup. A window with many configuration
options will open. As shown in the figure, turn on Realtime, and set the
Frames/Period to something like 1024. Larger values will provide more buffering,
but increase the latency between input, processing, and playback.  For many
applications, latency is less of a concern than buffer overruns and underruns
(called xruns in JACK parlance)

[[file:qjackctl-config.png]]

The correct driver to select will depend on the machine. On linux machines, the
correct choice is usually 'alsa'; on OS X machines the correct choice is usually
'coreaudio'. Close the setup window (with OK) and then click /Start/ in the main
interface. The display should show the the server is running along with some
useful statistics.

** Adjusting input and output gain

alsamixer tutorial...

** Making connections and visualizing data

JILL/JACK modules communicate with each other through ports. There are input
ports and output ports, and you can make connections from outputs to inputs to
move data around. In this section we'll demonstrate making connections with
=qjackctl= and a third-party visualization program, yass.

Start =yass= at the command line (e.g. =yass &=). By default, =yass= will create
two graphs, which can be connected to one or more output channels. Initially the
plots will be gray, indicating that there isn't any signal. Click 'Connect' in
=qjackctl= to open up an interface for making connections:

[[file:qjackctl-connect.png]]

To make a connection, select an output and an input port and click 'Connect'. In
the figure above I've connected the first capture channel of the soundcard to
the first channel of yass. If the channel is hooked up to a microphone or other
sound source, the yass plot will show its activity, as below.

[[file:yass.png]]

Note that you can connect multiple output ports to the same input port, in which
case the inputs will be /mixed/: the data from the output ports will be added
together, and this sum will appear in the input port. The same output port can
be connected to multiple input ports.

* Triggered recording

Let's say you want to record a bird's song, and you only want to save
the sound when the bird is singing.  The task, then, is to take data
from one of the channels on the sound card, run it through some kind
of detector, and then use that detector to determine when data from
that same channel gets written to disk.

** Detecting the signal

The =jdetect= module uses a simple window discriminator to detect when a signal
is occurring on a channel. It works by counting the number of times the signal
crosses a threshold, maintaining a running count that's compared against another
threshold. When the number of crossings in the analysis window (defined by the
user) exceeds a threshold, the discriminator's 'gate' opens. Once the gate is
open, the signal continues to be compared against a threshold (which can be
different), and a separate running count is kept. Once the number of crossings
drops below a certain number, the gate is closed.

There are a number of options for =jdetect= that are described in the program's
help (=jdetect -h=). For now, we'll use the default settings. The =jdetect=
program has three ports: an input port, an output port, and an optional status
port. The input port receives the auditory signal; the output port emits events
when the gate opens and closes. The status port is a readout of the running
threshold crossing count and is useful for setting thresholds.

JILL modules can be connected using =qjackctl= or =jack_connect=, but it's often
more convenient to connect the modules on startup using commandline options. To
start up the =jdetect= module and connect its input to the first capture
channel, and its status output to the oscilloscope:

: jdetect -i alsa_pcm:capture_1 --count-port

Now connect yass to the status port of =jdetect= using qjackctl or the following
shell command: =jack_connect jdetect:count yass:in_2=. The second channel of yass
will now show the output of the integrator, as below:

[[file:yass-integrate.png]]

Note how the signal in the upper trace causes the state of the integrator to
increase. When the integrator crosses its threshold, the output port of
=jdetect= will go high, and there will be a logged message, for example:

: 20130408T105856.109825 [jdetect] signal on:  frames=79373312, us=518609266225
: 20130408T105910.111175 [jdetect] signal off: frames=80038848, us=518623130887

The first set of numbers is a timestamp for the event, and jdetect also reports
the frame count (a number internal to the JACK system) and a
microsecond-resolution timestamp.

*** jdetect parameters

Choosing the parameters for =jdetect= can be a bit tricky, so a few pointers:

The open and close gates operate independently. If the open gate is too
sensitive, it will trigger on transient noises. If it's not sensitive enough, it
won't trigger weven then when the animal is vocalizing. If the close gate is too
sensitive, recording may stop during brief gaps in the vocalization. If it's not
sensitive enough the recordings may not stop.

The analysis granularity of both gates is controlled by /period-size/. Longer
periods are more efficient; smaller periods carry more fine-grained temporal
information.

Each gate is controlled by three parameters: /X-thresh/, /X-rate/, and
/X-period/. The average crossing rate must exceed (for opening) or drop below
(for closing) =X-rate / (period-size * X-period)=. Crossing rate is related to
the frequency and power of the signal.

The integration time is determined by =period-size * X-period=. Longer
integration times make the gates less sensitive to temporary dips or spikes in
power, at some cost in sensitivity and temporal resolution.

All *jill* modules can have their parameters specified on the command line or in
configuration files.  These files are in "ini" format, which consists of a
series of key-value pairs.  The keys in the file correspond to the long versions
of the commandline options for the module.  A configuration file for a =jdetect=
process might look like this:

: name=bu38t
: in=alsa_pcm:capture_1
: open-thresh=0.015
: open-rate=25
: close-thresh=0.015
: close-rate=10

When =jdetect= is started with the command =jdetect -C jdetect.ini=, it will
register with JACK as =bu38t=, connect to the port =alsa_pcm:capture_1=, and set
the detection parameters as specified.

** Triggered recordings

The =jdetect= module doesn't record data, but it can trigger other modules, like
=jrecord=. The =jrecord= module can record multiple channels, either
continuously or in response to a trigger event.

The =jrecord= module saves data in ARF format (https://github.com/dmeliza/arf),
a hierarchical storage format based on HDF5. Each recording episode is saved as
a separate entry (or group) in the ARF/HDF5 file. The input and trigger port can
be connected in =qjackctl=, or they can be specified on the command line:

: jrecord -t jdetect:trig_out -i alsa_pcm:capture_1 test.arf

The /pretrigger/ and /posttrigger/ options to =jrecord= tell it how much data to
record before the onset trigger and after the offset trigger. The default is a 1
second pretrigger.

* Recording stimulus-evoked activity

This section introduces a third module, =jstim=, which plays data from sound
files.  The output of =jstim= can be wired to an analog output of the sound
card, or to the input port of another JACK module.  In this example, we're going
to send the data to an output port while recording neural activity from several
input ports.

First, start =jrecord= in triggered acquisition mode:

: jrecord -t -f bu70_1.arf -i alsa_pcm:capture_1 -i alsa_pcm:capture_2 -i alsa_pcm:capture_3 ...

Or use a configuration file to specify the input ports:

: jrecord -C multichannel.ini -a animal=bu70 -a site=1 -f bu70_1.arf

Note the use of the =-a= flags to set attributes on the recorded entries.
=multichannel.ini= might look something like:

: trig
: in=system:capture_1
: in=system:capture_2
: in=system:capture_3
: in=system:capture_4
: in=system:capture_5
: in=system:capture_6
: in=system:capture_7
: in=system:capture_8
: in=system:capture_9
: in=system:capture_10
: in=system:capture_11
: in=system:capture_12

Next, instruct =jstim= to present a set of stimuli 10 times each in random
order, with 5 seconds between stimuli:

: jstim -s -r 10 -g 5 -o alsa_pcm:playback_1 -e jstim:trig_in stimuli/*.wav

Note that we've connected the sound output of jstim to a playback port on the
sound card, and the trigger output to the trigger input of jrecord.  You should
see jrecord create an entry for each stimulus as it's presented.

*IMPORTANT NOTE:* Do not attempt to write to the same ARF file with more than
 one =jrecord= process. The two processes have no way of coordinating their
 access to the file and the data will become corrupted. Multiple processes can
 read the same ARF file (for instance, you can open an ARF file to visualize
 already recorded data while =jrecord= is still recording), but only one can
 write.

* JILL ARF file structure

* Manipulating data streams with latency

file:jack-latency.png

JACK modules can introduce latency into the processing stream. act as data sources, sinks, or filters. =yass= and =jrecord=
are examples of data sinks: they have input ports but no output ports. A filter
has both input and output ports, and does something to the input data before
passing it on to the output. =jdetect= is a sort of filter, that transforms a
continuous audio stream into a series of events.

* Streaming audio over the network

This section is a placeholder.

https://github.com/jackaudio/jackaudio.github.com/wiki/WalkThrough_User_NetJack2

* Performance and stability

Tuning a computer for low-latency, reliable operation can be challenging. Modern
multithreaded operating systems are typically doing a lot in the background, and
there are often periods when the OS is tied up.  If your application depends on
receiving or producing a steady stream of samples, these periods of heavy
activity can lead to glitches and dropouts.

One option for dealing with these problems is to use large memory buffers, which
can hold samples during periods of heavy load. Large buffers mean long
latencies. This may not be a problem for many applications, like simply
recording data.

In closed-loop applications, the output of the system depends tightly on the
input, and latencies typically need to be short. How short depends on the nature
of the application. JACK can provide latencies on the order of 1-2 ms if
properly configured. It's important to recognize, though, that Linux and OS X
are not designed for realtime performance. Only a dedicated hard realtime system
can provide guarantees on latency. Below are some measures for improving
performance.

** Increase buffer size or decrease sampling rate

Larger periods give JACK clients more time to process the data and make the
whole system less vulnerable to xruns.  Period sizes need to be a power of two.
For example, to run JACK with a period size of 2048 samples:

: jackd -p 2048

Increasing the number of periods for playback latency may also help. In
=qjackctl= you can adjust these parameters in the setup window and it will
report the expected latency.

** Adjust other JACK parameters

Other things to try include:

1. Make the JACK daemon more forgiving of xruns. =jackd -Z ...=
2. Turn off playback ports. =jackd -d alsa -C ...=
3. Decrease the number of channel to what you need. To enable only 4 capture and
   playback ports: =jackd -d alsa -i 4 -o 4 ...=

Also try running JACK 2 instead of JACK 1; it's more fault tolerant and handles
port connections without glitching.

** Keep the system clean

Install a system with a minimal number of applications, and disable any
recurring operations.

** Install a low-latency kernel:

 CCRMA at Stanford maintains a repository with kernels that have been patched
for low latency operation (http://ccrma.stanford.edu/planetccrma/software/). You
need to be running CentOS 5 or Fedora 16-18 to use these kernels. You can also
try to recompile the kernel yourself with the realtime preemption patches
enabled.

** Disable CPU frequency scaling:

 Run =cpufreq-set -g performance= or =cpufreq-selector -g performance= as root.
Disable bus-frequency scaling, C1E halt states, and EIST in BIOS.

* Event framework

http://www.srm.com/qtma/davidsmidispec.html

* Other clients

There are many third-party JACK clients that can be used with the JILL
clients.  Some that might be useful:

** baudline

A very full-featured visualization client, with scrolling spectrograms and all.
Not open-source, and the interface is pretty non-standard, but very useful.
Doesn't work with JACK 2 as of this writing.

http://www.baudline.com/index.html

** faust

Faust is a system for specifying signal processors that can be compiled into
JACK modules with graphical user interfaces.

http://faust.grame.fr
