#-*- mode: org -*-
#+STARTUP:    align fold hidestars oddeven
#+TITLE:    JILL Real-Time Auditory Neuroscience Framework - Specification
#+AUTHOR:    Dan Meliza
#+EMAIL:     dan@meliza.org
#+LANGUAGE:   en
#+OPTIONS: ^:nil H:2
#+STYLE:    <link rel="stylesheet" href="org.css" type="text/css" />

JILL consists of a set of modules (programs) that use the JACK realtime audio
framework to do auditory neuroscience experiments. JACK provides a mechanism for
moving sampled data and events around between independent clients.  Clients can
read and write data to the JACK system through ports, and can serve as sources,
sinks, or filters.  This document is a specification for the programs in the
JILL framework; the spec for each module must follow the template below.

* Specification template

General comments about the function of the module.

** Ports

Specifications must indicate how many ports a module will register, their
function, their type (sampled or event) and their direction (input or output);
and whether the client will register, unregister, connect, or disconnect any
ports during normal operation.

** Events

The JACK framework is callback based, and clients must handle a range of
different events.  Thus, the specification for each module describes how it will
handle each of the events.  Not all clients have to handle all events.

1. the process callback, which reads and writes data to ports
2. registration or removal of ports in the JACK system. These can be anywhere in
   the JACK system, not necessarily in the client itself.
3. connection or disconnection of ports. Again, these connections can be
   anywhere in the JACK system, but for the purposes of this document, only
   connections to and from the client will be considered
4. overrun and underrun events (xruns). Caused when a client fails to exit its process
   loop in time
5. changes to period size. The period size is how many samples are passed to the
   clients in the process loop. Changes to period size cause gaps in the
   processing stream.
6. server shutdown. Clients should clean up any open files, etc, when this occurs.
7. changes to sampling rate. This callback exists but does not get called (at
   present writing) because the server cannot change sampling rate
8. timebase changes. These events occur when a client requests a new position in
   the processing stream. As of this writing, clients should ignore these events
   and must not request timebase changes.

** Signals

In addition, the specification must state how clients will handle standard POSIX
termination signals SIGINT, SIGTERM, and SIGHUP to avoid data loss.

** Options and behavior

This section describes commandline options and other details of behavior (e.g.,
whether it accepts input during operation).

* jdetect

The function of jdetect is to detect the onsets and offsets of sustained
auditory signals, such as when a bird vocalizes. It takes a single audio stream
as input and outputs events indicating when the signal crossed the start and
stop thresholds.

** Ports

+ in :: sampled data, input. The signal is processed to determined when it
        crosses onset or offset thresholds
+ trig_out :: event data, output. Emits note on and note off events indicating
              the times when the signal crossed the onset or offset threshold,
              respectively. The channel information in the event is not
              specified. Emits MIDI system events to indicate errors.
+ count :: (optional) sampled data, outout. Provides debug information about the
           state of the signal detector. The meaning of the signal depends on
           the implementation of the detector.

The client will not make any changes to its ports during operation.

** Events

1. The process callback reads data from the input stream and uses it to
   calculating a running estimate of the signal power. The detector will likely
   need to maintain state across periods.  If the signal crosses the onset or
   offset threshold, outputs a note on or note off event.
2. Port registration and unregistrations are ignored.
3. Port connections and disconnections are ignored.
4. Although xruns indicate missing data, the detector will continue to function
   on the available data. Even if the last event was a note on, a weak signal
   will eventually cause the offset threshold to be crossed, and the resulting
   note off signal will be in sync with the auditory data at that point.
5. Changes to buffer size are ignored, unless they necessitate a change to the
   parameters of the detector.
6. Server shutdowns cause the client to terminate.

** Signals

Termination signals have their default behavior (cause the client to exit).
Clients subscribing to the event port are responsible for detecting the
disconnection and handling the condition where the program is terminated after
a note on event but before a note off event.

** Options and behavior

The jdetect module accepts commandline options that specify the behavior of the
signal detector. These will depend on the implementation. Onset and offset
events and their times will be logged. The client may accept input during
operation to adjust these parameters, and it may provide information on the
terminal as to the current state of the detector.

*** TODO implement adjust parameters in running jdetect

* jrecord

The function of jrecord is to write sampled and event data to disk. Sampled
data may include audio and neural signals, and event data may include signal
detections (such as emitted by jdetect), spike times, and other external events.
Data are stored in HDF5 format (LINK) using the ARF specification (LINK).
Recording may be continuous, or may be in discrete epochs triggered by events.
In the latter case, a prebuffer provides the ability to record data prior to the
actual epoch onset event.

** Ports

+ in_NNN :: input. NNN is a numerical index. The number of ports and their type
            is determined at startup by specifying a list of ports to connect to
            the client.
+ trig_in :: input, events. In epoch mode, controls the start and stop of
             recording epochs. note on events cause epochs to start; note off
             events cause epochs to terminate. Multiple inputs may be connected
             to this port, in which case the events will be mixed. Note on
             events are ignored during recording epochs; note off events are
             ignored outside of recording epochs. Channel values less than 8
             initiate recording; all other channel values indicate the message
             is purely informative. All events, including their channel
             information, are logged. In continuous recording mode, this port
             will still be created, but it will not affect acquisition.

The client will not make any changes to its port configuration during operation.

** Events

1. The process callback places data into a ringbuffer.  Each period is stored as
   a chunk to ensure synchronization across channels. There is no output.
2. Registration/unregistration events are ignored.
3. Port connections and disconnections are logged to the output file. If the
   trigger port is disconnected, the program is in epoch mode, and recording is
   in progress, stops in the next period. Disconnected input ports will still be
   recorded, but will have zeros in the signal.
4. All xruns are logged to the output file. In continuous mode, xruns cause the
   current entry to be terminated (all data in ringbuffer is flushed to disk)
   and a new entry started. In epoch mode, xruns cause the entry to be flagged,
   but the data are recorded as is.
5. Changes to period size result in a log entry and cause all the data in the
   ringbuffer to be flushed to disk. Because this introduces a gap in the data
   stream, the current entry will be terminated. In continuous mode, a new entry
   will be started; in epoch mode no new entry is started. Furthermore, if the
   new size of the period is so large that less than three full periods will fit
   in the ringbuffer, the ringbuffer is resized.
6. Server shutdown causes remaining data in the ringbuffer to be flushed before
   the client terminates.

** Signals

SIGTERM, SIGINT, and SIGHUP all cause the client to flush data and terminate. To
maintain a running jrecord client, run it in a virtual screen.

** Options and behavior

Commandline options:

1. Epoch or continuous recording mode
2. Maximum file size. In continuous recordings, if the file size is exceeded,
   the current file will be closed and a new one opened, with no gap between the
   files. For epoch recordings, the last epoch will be written before changing
   to a new file. A value of 0 means there is no maximum (up to the file
   system's capabilities)
3. Output file name. If a maximum file size is specified, this is treated as a
   template and the files are named with a sequentially increasing numerical suffix.
4. Prebuffer size. Only takes effect in epoch mode. Specifies the amount of data
   (in units of time) write from before the time of the trigger to write to
   disk. This is treated as an approximate value, because the prebuffer may not
   fill completely, and for performance sake only complete periods may be used.
5. Ringbuffer size. Determines the size of the buffer used to move data from the
   realtime process thread to the writer thread. By default this is
   automatically set to hold at least ten complete periods of data, or 2
   seconds, whichever is more.
6. The number of input ports to create, or a list of ports to connect to. If
   inputs are specified as a list, a separate option (e.g. -I) is used to
   indicate that the full event information should be stored rather than just
   the time.  It may also be useful to have an option to connect to every
   output port on a client (for example, to record from all the channels on a
   sound card or DAQ board)
7. Optional key-value pairs, which will be stored in attributes of created
   entries.

On startup, jrecord will attempt to open the output file and obtain a write
lock. If either operation fails, the program will terminate with an error. The
program should attempt to determine if the output file is on an NFS share and
proceed with a stern warning.

Next, it will open the log table. This is an extensible dataset at the root of
the ARF file that can be used to log events. If the table does not exist, it is
created.

Next, it will create the JACK client, register ports, activate the client, and
connect the inputs.

In continuous mode, jrecord will create an entry and begin writing to the
disk immediately, and continue until the program is terminated.  Some
synchronization is necessary to ensure that data are not written to the disk
until the ports are connected.

In epoch mode, jrecord will wait until it receives a note on event on the
trigger port. While waiting, it will copy periods from the ringbuffer to the
prebuffer, freeing periods beyond the duration of the prebuffer window. On
receiving a note on event, it will log the event, open a new entry, write the
prebuffered data to the entry, and then start writing all subsequently received
data to the entry. On receiving a note off event it will close the dataset and
entry and begin storing data in the prebuffer again.

Each input channel will be stored in a separate dataset under the entry. Sampled
data will be stored in HDF5 array datasets, with elements corresponding to
individual frames. Event data will also be stored in HDF5 array datasets, but
the elements correspond to the times of the events. Additional information in
the event (type, channel, et al) is discarded. However, if the input port is
specified using a different option (see above), the full event data is stored
using an ARF interval table. Data from the trigger port is stored in interval
tables as well.

* jstim

The jstim module's function is to present auditory stimuli through the JACK
interface. Stimuli can be presented singly or as part of a batch. The stimuli in
a batch can be repeated and the order can be randomized. Presentation can occur
at fixed intervals, with fixed gaps between stimuli, or in response to an
external trigger. An event output line can be used to trigger other modules,
like jrecord. Can also be used for presentation of stimuli while searching for
neurons.

** Ports

+ out :: sampled, output. Carries the audio signal for the stimulus.
+ trig_out :: event, output. Generates note on events when the stimulus starts
              and note off events when it ends. For recording, the channel
              value is 0. For search, the channel value is 8. The event message
              is the name of the stimulus file (minus any path information).
+ trig_in :: (optional) event, input. Only created for triggered mode. Initiates
             stimulus playback synchronized to the time of any note_on events
             with channel values less than 8. Ignores note_off events.

** Events

1. The process callback copies data from a fixed buffer into the output port
   buffer. Between stimuli, writes zeros to the output. The use of fixed buffers
   assumes that stimuli are relatively short and memory is plentiful, but allows
   stimulus onset to be synchonized precisely with note on events. On stimulus
   onset, writes a note_on event to the event output. On stimulus offset, writes
   a note_off event to the event output. Also monitors a variable that indicates
   whether an xrun occurred, and if so, terminates playback and sends a system
   event message.
2. Registration/unregistration events are ignored
3. Port connections and disconnections are ignored
4. Xruns cause a flag shared with the process callback to be set so that an
   error event can be sent to downstream clients. Xruns are also logged.
5. Changes to period size also cause the xrun flag to be set, because this will
   result in a gap in the audio stream.
6. Server shutdown causes termination of the client.

** Signals

SIGINT, SIGTERM, and SIGHUP events cause termination of the client.

** Options and behavior

Commandline options:

1. Record or search mode
2. External trigger, fixed interval, or fixed gap. Keypress?
3. Number of repetitions
4. Whether to randomize stimulus order
5. List of stimulus files

On startup, load stimulus files into memory, resampling as necessary to match
sampling rate of the JACK system. Alternatively, first determine the order of
playback, load the first stimulus, and dispatch a thread to load the remaining
stimuli (some small danger of this not completing before they are needed).

Initialize client, register ports and callbacks, start client, connect ports.

When the process thread indicates it has played all the stimuli, shut down the
client and terminate program.

* jplot

Replaces splot, providing scrolling oscillogram and periplots for rasters.  It
may be possible to upgrade splot to a more recent version of gtk and replace its
signal acquisition routines with JACK callbacks.

* jspikes

Replaces aspikes for online spike detection.
